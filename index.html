<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="stylesheet" href="/css/index.css">
    <script src="/OrbitControls.js"></script>
    <script src="/three.min.js"></script>
    <title>Three.js - City -  GLTF</title>
   
  </head>
  <body>
    <!--
    <canvas id="c"></canvas>
    -->
    <div id="loading" style="display: block;">
      <div>
        <div>...loading...</div>
        <div class="progress" ><div id="progressbar"></div></div>
      </div>
    </div>
  </body>
<script type="module">
import * as THREE from './threejs/three.module.js';
import {OrbitControls} from './threejs/OrbitControls.js';
import {GLTFLoader} from './threejs/GLTFLoader.js';
import {SkeletonUtils} from './threejs/SkeletonUtils.js';

console.clear();


var keyboard = {};

var walker = {
	height: 1.8,
	speed: 0.5,
	turn: Math.PI * 0.01
};
var camDef = {
  fov : 45,
  aspect: 2,
  near: 0.1,
  far: 10000
};

var scene, camera, renderer;

window.addEventListener('resize', function () {
	var width = window.innerWidth;
	var height = window.innerHeight;
    renderer.setSize(width, height);
});



function main() {
  const canvas = document.querySelector('#c');
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(camDef.fov, camDef.aspect, camDef.near, camDef.far);
  camera.position.set(30, walker.height+1, 80);

  const controls = new OrbitControls(camera);
  //controls.addEventListener('change', renderer);
  controls.target.set(30, walker.height, 0);
  controls.minDistance = -10;
  controls.maxDistance = 700;
  //controls.update();
 

  scene = new THREE.Scene();
  //scene.background = new THREE.Color('grey');

  let materialArray = [];
  let texture_ft = new THREE.TextureLoader().load('/images/divine_ft.jpg');
  let texture_bk = new THREE.TextureLoader().load('/images/divine_bk.jpg');
  let texture_up = new THREE.TextureLoader().load('/images/divine_up.jpg');
  let texture_dn = new THREE.TextureLoader().load('/images/divine_dn.jpg');
  let texture_rt = new THREE.TextureLoader().load('/images/divine_rt.jpg');
  let texture_lf = new THREE.TextureLoader().load('/images/divine_lf.jpg');
  
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_ft}));
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_bk}));
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_up}));
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_dn}));
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_rt}));
  materialArray.push(new THREE.MeshBasicMaterial({map: texture_lf}));
   
            for (let i = 0; i < 6; i++)
           materialArray[i].side = THREE.BackSide;
        let skyboxGeo = new THREE.BoxGeometry( 10000, 10000, 10000);
        let skybox = new THREE.Mesh( skyboxGeo, materialArray );
        scene.add( skybox );  
        animate();

  function addLight(...pos) {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(...pos);
    scene.add(light);
    scene.add(light.target);
  }
  addLight(5, 5, 2);
  addLight(5, -5, 2);
  addLight(-5, 5, 5);
  addLight(0,0,0);

  const manager = new THREE.LoadingManager();
  manager.onLoad = init;

  const progressbarElem = document.querySelector('#progressbar');
  manager.onProgress = (url, itemsLoaded, itemsTotal) => {
    progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;
  };

  const models = {
    city:    { url: 'images/city/scene.gltf' },
    building:    { url: 'images/building_25/scene.gltf' },
  };
  {
    const gltfLoader = new GLTFLoader(manager);
    var scen1 = gltfLoader.load(models["city"].url, (gltf) => {
    var root = gltf.scene;
    root.position.set(93,3.8,30);
    root.scale.set(0.1, 0.1, 0.1);
    scene.add(root);
  });
  var scen2 = gltfLoader.load(models["city"].url, (gltf) => {
    var root = gltf.scene;
    root.position.set(-95.5,3.8,30);
    root.scale.set(0.1, 0.1, 0.1);
    scene.add(root);

  }); 
  var scen3 = gltfLoader.load(models["city"].url, (gltf) => {
    var root = gltf.scene;
    root.position.set(93,3.8,-160);
    root.scale.set(0.1, 0.1, 0.1);
    scene.add(root);
  });
  var scen4 = gltfLoader.load(models["city"].url, (gltf) => {
    var root = gltf.scene;
    root.position.set(-95.5,3.8,-160);
    root.scale.set(0.1, 0.1, 0.1);
    scene.add(root);

  });
}

var signs= [];

  function init() {
    // hide the loading bar
    const loadingElem = document.querySelector('#loading');
    loadingElem.style.display = 'none';

    //Signs
    {
    //Ikea
     var loader = new THREE.TextureLoader();
     var material = new THREE.MeshLambertMaterial({
       map: loader.load('images/ikea.jpeg')
       });
       
       var geometry = new THREE.PlaneGeometry(18, 10);
       var ikea = new THREE.Mesh(geometry, material);
       ikea.position.set(8.8,28,-143.5)
       ikea.userData = {URL: "http://www.ikea.se"};
       signs.push(ikea);
       scene.add(ikea);

        //Ikea side
     var loader = new THREE.TextureLoader();
     var material = new THREE.MeshLambertMaterial({
       map: loader.load('images/ikea.jpeg')
       });
       
       var geometry = new THREE.PlaneGeometry(18, 10);
       var ikea = new THREE.Mesh(geometry, material);
       ikea.position.set(21.5,28,-153.5)
       ikea.rotation.y = Math.PI/2;
       ikea.userData = {URL: "http://www.ikea.se"};
       signs.push(ikea);
       scene.add(ikea);

        //H&M
     var loader = new THREE.TextureLoader();
     var material = new THREE.MeshLambertMaterial({
       map: loader.load('images/hm.jpg')
       });
       
       var geometry = new THREE.PlaneGeometry(18, 10);
       var hm = new THREE.Mesh(geometry, material);
       hm.position.set(8.8,17,-143.5)
       hm.userData = {URL: "https://www2.hm.com/sv_se/rea.html"};
       signs.push(hm);
       scene.add(hm);

        //H&M side
     var loader = new THREE.TextureLoader();
     var material = new THREE.MeshLambertMaterial({
       map: loader.load('images/hm.jpg')
       });
       
       var geometry = new THREE.PlaneGeometry(18, 10);
       var hm = new THREE.Mesh(geometry, material);
       hm.position.set(21.5,17,-153.5)
       hm.rotation.y= Math.PI/2;
       hm.userData = {URL: "https://www2.hm.com/sv_se/rea.html"};
       signs.push(hm);
       scene.add(hm);
  }
  console.log(signs.length + " item in the Signs array");
  }
  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  let then = 0;
  function render(now) {
    now *= 0.001;  // convert to seconds
    const deltaTime = now - then;
    then = now;

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    //walking events
   if (keyboard[87]) { // W key go forward
		camera.position.x += Math.sin(camera.rotation.y) * walker.speed;
		camera.position.z += -Math.cos(camera.rotation.y) * walker.speed;
    console.log("W clicked");
	}
	if (keyboard[83]) { // S key go back
		camera.position.x -= Math.sin(camera.rotation.y) * walker.speed;
		camera.position.z -= -Math.cos(camera.rotation.y) * walker.speed;
    console.log("S clicked");
	}
	if (keyboard[68]) { // A key go left
		camera.position.x += Math.sin(camera.rotation.y + Math.PI / 2) * walker.speed;
		camera.position.z += -Math.cos(camera.rotation.y + Math.PI / 2) * walker.speed;
    console.log("D clicked");
	}
	if (keyboard[65]) { // D key  go right
		camera.position.x += Math.sin(camera.rotation.y - Math.PI / 2) * walker.speed;
		camera.position.z += -Math.cos(camera.rotation.y - Math.PI / 2) * walker.speed;
    console.log("A clicked");
	}

    //Turning the Cam events   
	if(keyboard[76]){ // L key
        camera.rotation.y += walker.turn;
        camera.position.x -= Math.sin(camera.rotation.y + Math.PI / 2) * walker.speed;
		camera.position.z -= -Math.cos(camera.rotation.y + Math.PI / 2) * walker.speed;
    console.log("L clicked");
	}
  if(keyboard[82]){ // R key
      camera.rotation.y -= walker.turn;
      camera.position.x += Math.sin(camera.rotation.y + Math.PI / 2) * walker.speed;
		camera.position.z += -Math.cos(camera.rotation.y + Math.PI / 2) * walker.speed;
    console.log("R clicked");
	} 
  /*  if(keyboard[38]){ // top arrow key
		camera.position.y += walker.turn * 2;
    console.log("Tilt Up clicked");
	}
	if(keyboard[40]){ // bottom arrow key
		camera.position.y -= walker.turn * 2;
    console.log("Tilt Down clicked");
	} 
 */
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}


function keyDown(e){
    keyboard[e.keyCode] = true;
}
function keyUp(e){
    keyboard[e.keyCode] = false;
}
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();

//Mus-klick event, ej klar då den inte separerar på objekten
function clicked(event){
    event.preventDefault();

    mouse.x = event.clientX / window.innerWidth * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0 ){
      if(!intersects[0].object.userData.URL == 0)
      window.open(intersects[0].object.userData.URL);
      //alert(intersects[0].object.userData.URL);
    }
}
function animate() {
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}

window.addEventListener('click', clicked );
window.addEventListener('keydown', keyDown);
window.addEventListener('keyup', keyUp);

main();
</script>
</html>

